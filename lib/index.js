// Generated by CoffeeScript 1.6.2
(function() {
  var BaseSchema, applyDefaults, inflection, jsonschema, observe, rdb, registry, walk,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  inflection = require('inflection');

  jsonschema = require('jsonschema');

  rdb = require('rethinkdb');

  observe = require('./Object.observe/Object.observe.poly');

  exports.plugin = function() {
    return null;
  };

  applyDefaults = function(properties, doc) {
    var def, name, prop, _results;

    _results = [];
    for (name in properties) {
      prop = properties[name];
      if (doc[name] == null) {
        def = prop["default"];
        if (typeof def === 'function') {
          def = def();
        }
        _results.push(doc[name] = def);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  exports.registry = registry = {};

  exports.BaseSchema = BaseSchema = (function() {
    function BaseSchema() {}

    BaseSchema.createTable = function(callback) {
      return rdb.db(this.db).tableCreate(this.table).run(this.connection, callback);
    };

    BaseSchema.dropTable = function(callback) {
      return rdb.db(this.db).tableDrop(this.table).run(this.connection, callback);
    };

    BaseSchema.clearTable = function(callback) {
      return rdb.db(this.db).table(this.table)["delete"]().run(this.connection, callback);
    };

    BaseSchema.create = function(doc) {
      var inst, res;

      inst = new this;
      inst.table = this.table;
      inst.db = this.db;
      inst.connection = this.connection;
      inst.key = null;
      applyDefaults(this.properties, doc);
      res = jsonschema.validate(doc, {
        properties: this.properties
      });
      if (res.errors.length) {
        inst.invalid = res;
        inst.doc = {};
      } else {
        inst.invalid = false;
        inst.doc = doc;
      }
      return inst;
    };

    BaseSchema.get = function(key, callback) {
      var con, self;

      self = this;
      con = this.connection;
      if (!con) {
        return callback({
          errmsg: 'not connected'
        });
      }
      return rdb.db(this.db).table(this.table).get(key).run(con, function(err, doc) {
        if (err) {
          return callback(err);
        }
        if (!doc) {
          return callback(null, null);
        }
        return callback(null, self.create(doc));
      });
    };

    BaseSchema.search = function(options, callback) {
      var con, q;

      con = this.connection;
      if (!con) {
        return callback({
          errmsg: 'not connected'
        });
      }
      q = options.q ? options.q : options;
      return rdb.db(this.db).table(this.table).filter(q).run(con, callback);
    };

    BaseSchema.prototype.toJSON = function() {
      return this.doc;
    };

    BaseSchema.prototype.del = function(callback) {
      var con;

      con = this.connection;
      if (!con) {
        return callback({
          errmsg: 'not connected'
        });
      }
      if (!this.key) {
        return callback({
          errmsg: 'no key'
        });
      }
      return rdb.db(this.db).table(this.table).get(this.key)["delete"]().run(con, callback);
    };

    BaseSchema.prototype.save = function(options, callback) {
      var con, self;

      if (typeof options === 'function') {
        callback = options;
      }
      self = this;
      con = this.connection;
      if (!con) {
        return callback({
          errmsg: 'not connected'
        });
      }
      return rdb.db(this.db).table(this.table).insert(this.doc).run(con, function(err, doc) {
        var key;

        if (err) {
          return callback(err);
        }
        key = doc.generated_keys[0];
        self.key = key;
        return callback(null, self);
      });
    };

    return BaseSchema;

  })();

  exports.schema = function(defn) {
    var Schema, connection, db, key, methods, name, properties, props, statics, table, value, _ref;

    defn = defn || {};
    name = defn.name;
    if (!name) {
      throw new TypeError('Schema name required');
    }
    db = defn.db || 'test';
    props = defn.properties || {};
    methods = defn.methods || {};
    statics = defn.statics || {};
    connection = defn.connection || null;
    properties = defn.properties || {};
    table = defn.table;
    if (!table) {
      table = inflection.pluralize(name.toLowerCase());
    }
    Schema = (function(_super) {
      __extends(Schema, _super);

      function Schema() {
        _ref = Schema.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Schema.connection = connection;

      Schema.table = table;

      Schema.db = db;

      Schema.properties = properties;

      Schema.modelName = name;

      return Schema;

    })(BaseSchema);
    for (key in statics) {
      value = statics[key];
      Schema[key] = value;
    }
    for (key in methods) {
      value = methods[key];
      Schema.prototype[key] = value;
    }
    return registry[name] = Schema;
  };

  exports.walk = walk = function(obj, callback, predicate) {
    var key, val, _results;

    if (!predicate) {
      predicate = (function() {
        return true;
      });
    }
    _results = [];
    for (key in obj) {
      val = obj[key];
      if (predicate(key, val)) {
        callback(key, val);
        if (typeof val === 'object') {
          _results.push(walk(val, callback, predicate));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

}).call(this);
